# SOLID ( OOP 5 원칙 )
객체 지향 설계에서 변화에 잘 대응하는 것은 매우 중요한 일입니다. 그렇기에 객체 지향적으로 좋은 설계란 새로운 요구사항이나 변경사항이 있을 때, 변경 범위가 작은 설계를 뜻합니다.

> 좋은 설계는 변화에 유연하게 대처할 수 있고 확장에 용이한 특징을 가집니다. 

SOLID 객체 지향 원칙들을 지킴으로써 자연스럽게 좋은 설계들을 위해 필요한 것에 대해서 고민하게 됩니다.
1. 유지보수에 용이한 설계
2. 확장에 용이한 설계
3. 복잡하지 않은 설계

위와 같은 설계는 궁극적으로 개발자의 생산성에 큰 영향을 미치게 됩니다.


## SRP ( 단일 책임 원칙, Single Responsibility Principle )
> 하나의 객체는 하나의 책임만을 담당해야 한다는 원칙입니다. 

한 책임을 위한 여러개의 기능을 가지는 것은 상관습니다. <br>
예를 들어 계산기는 계산에 대한 책임만 가질 뿐 계산한 값을 토대로 표나 그래프를 만들어주는 책임을 가질 필요는 없습니다.<br>

객체들이 여러 책임을 가질 경우 하나의 변경사항이 책임을 가진 모든 객체들에게 연쇄적으로 전파되게 되며 이는 유지보수상의 어려움으로 이어지게 됩니다.

## OCP ( Open-Closed Principle, 개방 폐쇄 원칙)
> 확장에는 열려있고 수정에는 닫혀있어야 한다는 원칙입니다.
- 확장에 열려있다는 것은 기능이 추가될 때 기존 클래스의 확장을 통해 간단하게 기능을 확장할 수 있는 것을 뜻합니다.
- 수정에 대해 닫혀 있다는 것은 기능을 추가하거나 변경시 기존의 코드를 수정하지 않아도 됨을 뜻합니다.

### 숫자를 생성하는 방식이 변경되는 경우
1. OCP 를 위반하는 경우
   - 새로운 숫자 생성 클래스를 만든다. ( 확장에 닫혀 있음 )
   - 새로 생성한 클래스를 사용하도록 기존 코드들을 변경한다. ( 수정에 닫혀 있지 않음 )

2. OCP 를 지키는 경우
   - 숫자 생성 기능을 NumberGenerator 인터페이스로 추상화하여 사용하는 클래스가 추상화에 의존하게 한다.
   - 숫자 생성 방식을 확장할 때 NumberGenerator 를 구현한 새로운 클래스를 만든다. ( 확장에 열려 있음 )
   - 사용하는 클래스는 NumberGenerator에 의존함으로써 컴파일 시점에 코드의 수정없이 생성 방식을 유연하게 변경할 수 있다. ( 변경에 닫혀 있음 )

## LSP ( Liskov Substitution Principle, 리스코프 치환 원칙)
> 올바른 상속 관계를 위한 원칙으로 하위 타입은 상위타입으로 완전히 대체할 수 있어야 함을 뜻합니다.

이를 위해서 하위 클래스는 상위 클래스의 규약을 따라야 합니다. <br>

### 정사각형, 직사각형을 상속관계로 설계하는 경우
> 현실에서 정사각형은 직사각형 입니다.

직사각형이라는 객체에 가로 세로를 변경하는 기능을 추가하고 정사각형이 직사각형을 상속받았다고 가정하겠습니다.
- 정사각형의 가로 변경 기능에는 가로 세로가 동일해야한다는 요구사항이 추가되어야 합니다.
- 직사각형에는 추가되어야 할 필요가 없습니다. 
이는 정사각형 타입이 직사각형 타입으로 완전히 대체될 수 없음을 뜻합니다. <br>

이처럼 상속관계를 가질 때 LSP 원칙을 따르는지 고민하여 올바른 상속관계인지 고민해볼 수 있습니다.


## ISP ( 인터페이스 분리 원칙 )
> 사용하지 않는 인터페이스를 구현하는 일이 없도록 큰 인터페이스를 작은 여러개의 인터페이스로 나누자는 것을 뜻합니다. ( 인터페이스 단일 책임 )

여러개의 인터페이스를 구현한 클래스를 지정한 인터페이스 타입으로 사용하게 강제할 수 있습니다.
- 필요한 메서드에만 접근하게 하여 개발자의 의도대로 사용하도록 제한할 수 있습니다.
- 기능 확장이나 수정시 여러개의 인터페이스로 나누었기에 변경이 미치는 범위가 작아 유지보수에 장점을 가집니다.

## DIP ( 의존성 역전의 원칙 )
> 구체적인 것(하위 모듈)보다 추상적인 것(상위 모듈)에 의존하라는 뜻입니다.  

상위 모듈이 하위 모듈보다 변경이 될 가능성이 적습니다. OCP 와 연결이 되는 경우가 많습니다.
( DIP 의 예시는 숫자 생성 기능을 확장할 때 추상화를 사용하는 OCP 예시와 동일하며 같은 장점을 가집니다. )
